---
title: muduo学习日志
date: 2019-04-18 14:33:32
tags: 
- muduo 
- c++ 
- 多线程
---

> 记录muduo库及多线程的一些要点，主要参考于陈硕《Linux多线程服务端编程》

#### 一  线程安全的对象生命期管理

##### 线程安全的定义

一个线程安全的类应大致满足一下三个条件：

1. 多个线程同时访问时，其表现出正确的行为

2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织

3. 调用端代码无须额外的同步或其他协调动作

使用**同步原语**保护内部状态编写单个的线程安全类：

```C++
class ThreadsafeCounter {
	mutable std::mutex m; // “ M&M 规则”： mutable 与 mutex 一并出场
	int data = 0;
public:
	int get() const {
		std::lock_guard<std::mutex> lk(m);
		return data;
	}
	void inc() {
		std::lock_guard<std::mutex> lk(m);
		++data;
	}
}
```

##### 对象的构造

线程安全要求在构造期间不泄露this指针，原因在于如果构造期间如果对象没有完成初始化而泄漏给其他对象

1. 不要在构造函数中注册回调
2. 不要再构造函数中把this传给跨线程的对象

##### 对象的析构

mutex在析构时的局限性：作为成员的互斥器本身必须是有效的，而析构函数将破坏了这一假设，它会把mutex成员变量销毁掉。因此作为数据成员的mutex 不能保护析构。析构过程本身也不需要保护，因为只有别的线程都访问不到这个对象时，析构才是安全的。

##### 空悬指针问题

当指针暴露给别的线程是，指向对象的原始指针往往是不可靠的。

![fig1](muduo学习日志/fig1.png)

空悬指针式一种典型的内存错误。解决空悬指针的办法是引入一层间接性，让指针所指的对象永久有效。

![fig2](muduo学习日志/fig2.png)

但安全释放object又是一个问题。解决办法是是引入引用计数，整数计数型智能指针shared_ptr/weak_ptr。

关于shared_ptr / weak_ptr 的有关说明，在[cppreference](https://zh.cppreference.com/w/cpp/memory/shared_ptr)均有较为详细的说明。简而言之，shared_ptr控制对象的生命期，它是强引用，只要对象存在指向它的shared_ptr存在，该对象就不会被销毁。使用weak_ptr探查对象的生死。

shared_ptr实现线程安全的对象释放，但其shared_ptr本身不是100线程安全的。

#### 二  线程同步

##### 四项原则

1. 尽量最低限度地共享对象，减少需要同步的场合
2. 使用高级的并发编程构件，如TaskQueue
3. 不得已使用底层同步原语（primitives）时，只用非递归的互斥器和条件变量，慎用读写锁，不要用信号量
4. 除了使用atomic整数之外，不自己编写lock-free代码，也不要用内核级同步原语。

##### 互斥器

互斥器是使用最多的同步原语，它保护了临界区，任何一个时刻最多只能有一个线程在此mutex划出的临界区内活动。使用互斥器时要注意以下几点：

1. 使用RAII封装mutex的创建、销毁、加锁、解锁四个操作。
2. 只用非递归的mutex
3. 不手工调用lock和unlock函数，一切交给栈上的Guard对象的构造和析构函数负责

##### 条件变量 

